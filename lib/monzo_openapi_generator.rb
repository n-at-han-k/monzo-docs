# frozen_string_literal: true

require 'yaml'
require 'json'

module MonzoOpenAPIGenerator
  class << self
    # Generate the full OpenAPI document (Hash)
    def generate(input_text)
      Generator.new(input_text).generate
    end

    # Convenience: write YAML directly
    def dump_yaml(input_text, io = $stdout)
      io.puts YAML.dump(generate(input_text), line_width: 120)
    end

    # Convenience: write pretty JSON directly
    def dump_json(input_text, io = $stdout)
      io.puts JSON.pretty_generate(generate(input_text))
    end
  end

  # ------------------------------------------------------------------
  # Private class that does all the heavy lifting
  # ------------------------------------------------------------------
  class Generator
    def initialize(text)
      @text = text
    end

    def generate
      @openapi = base_structure
      extract_sections
      extract_http_examples
      add_missing_endpoints
      @openapi
    end

    private

    def base_structure
      {
        openapi: "3.1.0",
        info: {
          title: "Monzo API (Legacy Personal + Open Banking)",
          version: "1.0.0",
          description: "Auto-generated OpenAPI 3.1 specification from Monzo's official Markdown documentation",
          contact: { name: "Generated by monzo-docs" }
        },
        servers: [
          { url: "https://api.monzo.com" },
          { url: "https://openbanking.monzo.com/open-banking/v3.1" }
        ],
        tags: [],
        paths: {},
        components: {
          securitySchemes: {
            bearerAuth: {
              type: "http",
              scheme: "bearer",
              description: "Personal API access token obtained via OAuth 2.0"
            },
            openBankingAuth: {
              type: "oauth2",
              description: "Open Banking OAuth2 flow (tls_client_auth)",
              flows: {
                authorizationCode: {
                  authorizationUrl: "https://auth.monzo.com",
                  tokenUrl: "https://api.monzo.com/oauth2/token",
                  scopes: {}
                }
              }
            }
          }
        },
        security: [{ bearerAuth: [] }]
      }
    end

    def extract_sections
      @sections = @text.scan(/^# (.+?)\n([\s\S]*?)(?=(?:^# |\z))/m).map do |title, content|
        title = title.strip
        { title: title, content: content.strip, id: title.downcase.gsub(/[^a-z0-9]+/, '-') }
      end

      @sections.each do |sec|
        next if sec[:title].start_with?('_')
        @openapi[:tags] << {
          name: sec[:title],
          description: sec[:content].lines.first(3).join.strip
        }
      end
    end

    def extract_http_examples
      @text.scan(/\n```shell\n\$ http(?: --form)?\s+([A-Z]+)\s+"(https?:\/\/[^"]+)"([^`]*)```/m).each do |method, url, raw_body|
        process_http_example(method.upcase, url, raw_body.strip)
      end
    end

    def process_http_example(method, full_url, raw_body)
      return unless %w[GET POST PUT PATCH DELETE].include?(method)

      path = full_url
             .sub(%r{https?://api\.monzo\.com}, '')
             .sub(%r{https?://openbanking\.monzo\.com/open-banking/v3\.1}, '')
             .gsub(/\$[a-zA-Z0-9_]+/) { |m| "{#{m[1..]}}" }

      params      = extract_params(raw_body)
      is_form     = raw_body.include?("--form")
      json_example = extract_json_example(full_url)

      summary = find_summary_for_url(full_url.split('?').first) || "No description"
      tag     = find_tag_for_url(full_url.split('?').first)

      operation = {
        summary: summary,
        operationId: "#{method.downcase}_#{path.tr('/', '_').gsub(/[^a-z0-9_]/i, '')}".gsub(/_+$/, ''),
        tags: [tag],
        parameters: params.uniq { |p| [p[:in], p[:name]] },
        responses: {
          "200" => {
            description: "Successful response",
            content: json_example ? { "application/json" => { example: json_example } } : {}
          }
        },
        security: path.include?("open-banking") ? [{ openBankingAuth: [] }] : [{ bearerAuth: [] }]
      }

      if method != "GET" && (is_form || json_example)
        content_type = is_form ? "application/x-www-form-urlencoded" : "application/json"
        operation[:requestBody] = {
          content: {
            content_type => json_example ? { example: json_example } : { schema: { type: "object" } }
          }
        }
      end

      @openapi[:paths][path] ||= {}
      @openapi[:paths][path][method.downcase] = operation
    end

    def extract_params(raw_body)
      raw_body.lines.map do |line|
        line = line.strip
        next if line.empty? || line.start_with?("Authorization:")
        if line.include?("==")
          k, v = line.split("==", 2)
          {
            name: k.strip,
            in: "query",
            required: true,
            schema: { type: "string" },
            example: v&.strip&.delete('"')
          }
        end
      end.compact
    end

    def extract_json_example(url)
      match = @text.match(/```shell\n.+#{Regexp.escape(url)}[^`]*```\n+```json\n(.*?)\n```/m)
      return nil unless match
      JSON.parse(match[1])
    rescue JSON::ParserError
      nil
    end

    def find_summary_for_url(url_part)
      sec = @sections.find { |s| s[:content].include?(url_part) }
      return nil unless sec
      sec[:content].lines.find { |l| l.start_with?("## ") }&.sub(/^##\s+/, '')&.strip || sec[:title]
    end

    def find_tag_for_url(url_part)
      sec = @sections.find { |s| s[:content].include?(url_part) }
      sec ? sec[:title] : "Uncategorized"
    end

    def add_missing_endpoints
      extras = {
        "/ping/whoami" => {
          get: {
            summary: "Verify authentication (whoami)",
            operationId: "get_ping_whoami",
            tags: ["Authentication"],
            responses: {
              "200" => {
                description: "Authenticated",
                content: { "application/json" => { example: { authenticated: true, client_id: "oauthclient_...", user_id: "user_..." } } }
              }
            }
          }
        },
        "/attachment/upload" => { post: { summary: "Obtain pre-signed upload URL", tags: ["Attachments"] } },
        "/attachment/register" => { post: { summary: "Register attachment against transaction", tags: ["Attachments"] } },
        "/attachment/deregister" => { post: { summary: "Deregister attachment", tags: ["Attachments"] } }
      }

      extras.each do |path, methods|
        @openapi[:paths][path] ||= {}
        methods.each do |m, spec|
          @openapi[:paths][path][m] ||= spec.merge(security: [{ bearerAuth: [] }])
        end
      end
    end
  end
end
